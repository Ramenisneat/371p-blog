---
title: "CS 371p Fall 2026: Rahul Myana : Blog 2"
date: 2026-01-25T19:15:16-06:00
draft: false
toc: false
images:
tags: 
  - untagged
---
<img src="../../headshot.jpg" width="200"/>

## Blog Entry noÂ°2

**What's up ðŸ‘‹**

I hope y'alls winter storm is going well. I'm having fun sliding around in my truck and getting flanked on all sides by 15mph drivers. I get it, it's scary but let me pass, pleaseee ðŸ˜­
<figure>
  <img src="../../red-bull-racing-hero.jpg" width="500"/>
  <figcaption>Me trynna get to work this morning</figcaption>

</figure>
<br>
Honestly, I haven't done too much in regards with this class this week. I barely started with the project, so i'll hunker down tonight and make a dent in it ðŸ™‡

I think one aspect of this class that "surprised" me was how structured everything is. As in the software side of things. It's very professional as in how an actual software development project would be structured as. I've done some professional software work before, but it has always been one off projects, so the repos were not as meticulously crafted as I see in this class. There are some things I disagree with, like some lines in the makefile, but overall I see it's utility.  

The Kattis problem this week was also pretty interesting. It took me a while to understand what the question is actually asking for and I had to think of a solution that didn't have a huge time complexity. The solution clicked for me when I saw that in the sample input/output, the second cycle always had fewer steps to the meeting point. I used hashmaps for the first time in c++ to solve this problem, took me a second to understand the API. Then I wasted a submission when I used a orderedmap vs an unorderedmap. The orderedmap added a lot to the runtime to sort the keys, when that's simply not needed for this problem. I like the simplicity of my solution and how plain it is, but I kind of feel like it's "bulky" in a sense that I am using hashmaps for a real simple cycle representation. I think you could get by with just a memorymap with pointers cause the keys are always positive integers. Actually, just typing that out solidified it in my mind that it would work, but I don't particularly agree with a solution like that cause it would be slightly harder to understand the code.  

Okie, now for my pick-of-the-week, I would have to say it's the vscode extension `latex-workshop`. Its a nice way to compile latex documents to pdfs in the vscode environment and I find it easier than working with overleaf on a seperate browser tab. It is kind of a pain to get it working, but I still like it

